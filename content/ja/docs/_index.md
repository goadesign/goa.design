---
title: "Goaを発見する"
linkTitle: "Goaを発見"
weight: 20
description: >
  Goa — GoでマイクロサービスとAPIを構築するためのデザインファーストフレームワークのドキュメント。
---

## API開発を変革する

マイクロサービスとAPIの世界では、設計と実装のギャップが常に課題でした。Goaは、Goでサービスを構築する方法を変革する革新的なアプローチでこのギャップを埋めます。設計を最前線に置くことで、Goaは従来の開発を悩ませてきた仕様、実装、ドキュメント間の面倒なやり取りを排除します。

APIを一度記述するだけで、必要なすべて（サーバーコード、クライアントライブラリ、ドキュメントなど）が自動的に生成されることを想像してください。これは夢ではありません—Goaが実現します。Goの型システムと最新の設計原則を活用することで、Goaは堅牢で本番環境対応のサービスを従来の何分の一かの時間で構築するのに役立ちます。

## Goaが違う理由

GoaはAPIの設計を生きた契約として扱うことで際立っています。このデザインファーストのアプローチは以下を意味します：

* APIドキュメントは常にコードと同期—同じソースから生成されるため
* 実装は型安全なインターフェースを通じて設計と一致することが保証される
* ビジネスロジックを変更せずにHTTPとgRPCを切り替えられる
* 価値を提供する機能の構築に集中できる

## Goaの仕組み

![Goaのレイヤードアーキテクチャ](/img/docs/layers.png)

ここで魔法が起こります。単一の設計ファイルから、Goaは通常手作業で書いて維持するのに数週間かかるコードの連鎖を解き放ちます。あなたは何が欲しいかを記述することに集中し、Goaが重い仕事を処理します：

1. 実装コード - 基盤
    * 本番環境対応のサービスとクライアントインターフェース
    * コードをクリーンに保つトランスポート非依存のエンドポイント
    * そのまま動作するHTTPとgRPCハンドラー
    * 書きたくないリクエスト/レスポンスのエンコーディングすべて

2. 自己宣伝するドキュメント
    * 美しいOpenAPI仕様
    * クロスプラットフォーム使用に対応したProtocol Buffer定義
    * 後付けではなく、コードと共に進化するドキュメント

3. さらに一歩
    * 堅牢な入力バリデーション
    * 本番品質のエラー処理
    * ユーザーが感謝するクライアントライブラリ

最良の部分は？Goaが何千行ものボイラープレート、テスト、ドキュメントを生成する間、あなたは重要なコード—ビジネスロジック—だけを書けばよいのです。あなたのコード3行が、HTTPとgRPCサポート、コマンドラインツール、包括的なAPIドキュメントを持つ完全な本番環境対応サービスに変わります。

## シンプルな例
GoaでAPIを設計するとこのようになります：

```go
var _ = Service("calculator", func() {
    Method("add", func() {
        Payload(func() {
            Field(1, "a", Int, "最初の数")
            Field(2, "b", Int, "2番目の数")
            Required("a", "b")
        })
        Result(Int)

        HTTP(func() {
            GET("/add/{a}/{b}")
            Response(StatusOK)
        })
    })
})
```

そして実装するために書く必要があるコードはこれだけ：

```go
func (s *service) Add(ctx context.Context, p *calc.AddPayload) (int, error) {
    return p.A + p.B, nil
}
```

## 主要なコンセプト

### デザインファースト：唯一の真実の源

複数のAPI仕様、ドキュメント、実装ファイルをやりくりするのをやめましょう。Goaでは、設計が契約です—全員を同じページに保つ明確で実行可能な仕様。チームはこのアプローチを好みます。「でも仕様はそう言ってなかった」という会話を永久に排除するからです。

### スケールするクリーンアーキテクチャ

Goaはシニアアーキテクトが夢見るようなコードを生成します。各コンポーネントはその完璧な場所に存在します：
* サービス層：純粋でクリーンなドメインロジック
* エンドポイント層：トランスポート非依存のビジネスフロー
* トランスポート層：ニーズに適応するHTTP/gRPCハンドラー

これは単なるアーキテクチャ理論ではありません—ニーズの進化に合わせてサービスをテスト、修正、スケールしやすくする動くコードです。

### あなたを支える型安全性

ランタイムの驚きを忘れましょう。GoaはGoの型システムを活用してコンパイル時に問題をキャッチします：

```go
// 生成されたインターフェース - あなたの契約
type Service interface {
    Add(context.Context, *AddPayload) (int, error)
}

// あなたの実装 - クリーンで焦点を絞った
func (s *service) Add(ctx context.Context, p *calc.AddPayload) (int, error) {
    return p.A + p.B, nil
}
```

実装が設計と一致しない場合、コードが本番環境に到達する前にわかります。

### 理にかなったプロジェクト構造

ファイルをどこに置くべきか推測する必要はもうありません。Goaプロジェクトは明確な構成に従います：

```
├── design/         # API設計 - 真実の源
├── gen/            # 生成されたコード - これを編集しない
│   ├── calculator/ # サービスインターフェース
│   ├── http/       # HTTPトランスポート層
│   └── grpc/       # gRPCトランスポート層
└── calculator.go   # あなたの実装 - 魔法が起こる場所
```

各ファイルにはその場所があり、チームのすべての開発者はどこを見ればいいか正確にわかります。

## 次のステップ

* [はじめにガイド](2-getting-started)に従う
* [コアチュートリアル](3-tutorials)を探索する
* コミュニティに参加：
    * [Gophers Slack](https://gophers.slack.com/messages/goa)
    * [GitHub Discussions](https://github.com/goadesign/goa/discussions)
    * [Bluesky](https://goadesign.bsky.social)
