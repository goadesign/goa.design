---
title: "なぜGoa-AI？"
linkTitle: "なぜGoa-AI？"
weight: 2
description: "堅牢なエージェントシステムを構築するために、なぜGoa-AIが正しい選択なのかを理解しましょう。"
---

`goa-ai`はGoで本番環境グレードのエージェントを構築するための**意見を持った、デザインファーストフレームワーク**です。

多くのフレームワークが*プロンプトエンジニアリング*（チェーン、テンプレート）や*ラピッドプロトタイピング*に焦点を当てる一方、`goa-ai`は**ソフトウェアエンジニアリング**に焦点を当てています：アーキテクチャ、型安全性、信頼性、そして構成可能性です。

汎用LLMライブラリではなくGoa-AIを使う理由は以下の通りです：

## 1. デザインファーストの契約（「Goa」のやり方）

エージェント、ツール、ポリシーを**DSL**（ドメイン固有言語）で定義します。`goa-ai`はグルーコードを生成します。

*   **なぜ重要か**：ツール引数のための脆い「文字列パース」コードを書く必要がありません。
*   **結果**：ツールは**強力なスキーマ**を持ちます。LLMが欠落フィールドでツールを呼び出した場合、*生成されたコード*が境界でそれをキャッチし、プランナーが自動的に修正できるように構造化された**自動修復ヒント**（`RetryHint`）を提供します。エージェントのインターフェースに対してコンパイル時の安全性が得られます。

## 2. ファーストクラスアクターとしてのエージェント

`goa-ai`では、エージェントは単なるプロンプトループではありません。それは**サービス**です。

*   **Agent-as-Tool**：エージェント全体（例：`ResearchAgent`）を別のエージェント（例：`ChatAgent`）の*ツール*として登録できます。
*   **実行ツリー**：ランタイムはこの階層を追跡します。実行を「フラット化」せず、**実行ツリー**（親 → 子 → ツール）を維持します。
*   **なぜ重要か**：クリーンに構成される小さな専門エージェントから複雑なシステムを構築できます。ランタイムがコンテキストの受け渡しと実行のリンクの「配管」を処理します。

## 3. 構造化ストリーミング（単なるテキストではない）

ほとんどのフレームワークは生のテキストトークンをストリーミングします。`goa-ai`は**型付きイベント**をストリーミングします。

*   **体験**：UIは特定のイベントを受け取ります：`AssistantReply`、`PlannerThought`、`ToolStart`、`AgentRunStarted`。
*   **トポロジー対応**：ストリームはUIに*正確に*何が起きているかを伝えます：「チャットエージェントがリサーチエージェントの子実行を開始しました。」
*   **なぜ重要か**：これにより、単なるチャットバブルではなく**リッチなUI**（「エージェントカード」や「思考アコーディオン」のような）が可能になります。出力だけでなく、思考プロセスの*構造*をレンダリングできます。

## 4. 本番環境対応ランタイム

デモだけでなく、「2日目」の運用のために構築されています。

*   **耐久性**：**Temporal**ワークフローのファーストクラスサポート。エージェントは数日間実行でき（例：「このインシデントを監視」）、再起動を乗り越えます。
*   **ポリシーとキャップ**：厳格な制限を強制（例：「最大5回のツール呼び出し」、「2分の予算」）。
*   **可観測性**：すべての実行は`RunID`、`SessionID`、`TurnID`で追跡されます。トランスクリプトをMongoに永続化し、後で検索できます。
*   **MCP統合**：**Model Context Protocol**のネイティブサポートにより、エージェントは外部ツールサーバー（GitHub、Slack、Postgres）を即座に使用できます。

## まとめ：システム vs スクリプト

スクリプトではなく**システム**を構築している場合は`goa-ai`を使用してください。

*   **もし欲しいのが**：「PDFとチャット」する簡単なスクリプトをハックしたり、午後にアイデアをプロトタイプしたい → 動的言語ライブラリを使用。
*   **もし欲しいのが**：エージェントがサービスであり、ツールが強く型付けされ、UIがシステムの実際の状態を反映する、信頼性があり拡張可能なプラットフォームを構築したい → **`goa-ai`を使用**。
