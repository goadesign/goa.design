---
title: "セッション、ラン、メモリ"
linkTitle: "セッション & ラン"
weight: 4
description: "Goa-AIにおけるセッション、ラン、メモリの関係を理解する。"
---

Goa-AIはエージェント実行を階層的に整理します：セッションにはランが含まれ、ランにはターンが含まれ、メモリはすべてにまたがります。

## 階層

```
セッション
  └─ ラン（エージェントの1回の実行）
       └─ ターン（メッセージの往復）
            └─ ツールコール
```

## セッション

**セッション**は会話の単位です。ユーザーがチャットを開始すると、セッションが作成されます。セッションは以下を追跡します：

- 一意のセッションID
- 作成タイムスタンプ
- 関連するランへの参照
- オプションのメタデータ（ユーザーID、コンテキストなど）

```go
session, err := rt.CreateSession(ctx, &session.CreateInput{
    Metadata: map[string]string{
        "user_id": "user-123",
    },
})
```

## ラン

**ラン**はエージェントの1回の実行です。ユーザーがメッセージを送信するたびに、新しいランが開始されます。ランは以下を含みます：

- 一意のランID
- 親セッションへの参照
- ステータス（実行中、完了、失敗など）
- タイムスタンプ（開始、終了）
- オプションのラベル（ポリシー用）

```go
result, err := rt.Run(ctx, agentID, prompt, agent.WithSession(sessionID))
```

## メモリ

**メモリ**は会話履歴を超えて持続する長期的なコンテキストです。メモリは以下に使用できます：

- ユーザーの好み
- 学習した事実
- エージェント間で共有されるコンテキスト

```go
// メモリを保存
err := rt.StoreMemory(ctx, &memory.Entry{
    Key:     "user-preference",
    Value:   "dark mode",
    Scope:   memory.ScopeSession,
    Session: sessionID,
})

// メモリを取得
entry, err := rt.GetMemory(ctx, "user-preference", sessionID)
```

## 実践例

典型的なチャットアプリケーションのフロー：

1. ユーザーがチャットを開始 → **セッション作成**
2. ユーザーがメッセージを送信 → **ラン開始**
3. エージェントがツールを使用 → **ツールコール記録**
4. エージェントが応答 → **ラン完了**
5. ユーザーが別のメッセージを送信 → **新しいラン開始**
6. セッションが終了 → **セッション更新**

このモデルにより：

- **デバッグ**：各ランを個別に検査可能
- **監査**：すべてのツールコールと決定を追跡
- **再開**：中断されたセッションを継続可能


