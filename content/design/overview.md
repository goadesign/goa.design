+++
date = "2016-04-16T11:01:06-05:00"
title = "The goa API design language"
weight = 1
+++

The Goa API Design Language is a DSL implemented in [Go](https://golang.org) that makes it possible
to describe arbitrary microservice APIs. While the main focus is REST based HTTP APIs, the language
is flexible enough to describe APIs that follow other methodologies as well.
[Plugins](/extend/dsls) can extend the core DSL to allow describing other aspects of
microservices such as database models, service discovery integrations, failure handlers etc.

## Design Definitions

At its core the design language consists of functions that are chained together to describe
*definitions*. The goa design language root definition is the API definition, the DSL to define it
looks like this:

```go
import (
    . "github.com/goadesign/goa/design"
    . "github.com/goadesign/goa/design/apidsl"
)

var _ = API("My API", func() {        // "My API" is the name of the API used in docs
    Title("Documentation title")      // Documentation title
    Description("The next big thing") // Longer documentation description
    Host("goa.design")                // Host used by Swagger and clients
    Scheme("https")                   // HTTP scheme used by Swagger and clients
    BasePath("/api")                  // Base path to all API endpoints
    Consumes("application/json")      // Media types supported by the API
    Produces("application/json")      // Media types generated by the API
})
```

*A side note on "dot import" as this question comes up often: the goa API design language is a DSL
implemented in Go and is __not__ Go. The generated code or any of the actual Go code in goa does
not make use of "dot imports". Using this technique for the DSL results in far cleaner looking
code. It also allows mixing DSLs coming from plugins transparently, moving on...*

The DSL makes heavy use of anonymous functions to describe the various definitions recursively.
In the example above the
[API](https://goa.design/reference/goa/design/apidsl/#func-api-a-name-apidsl-api-a:aab4f9d6f98ed71f45bd470427dde2a7)
function accepts the name of the API as first argument and an anonymous function as second
argument. This anonymous function also referred to as `DSL` in this document defines additional
properties of the API. This pattern (name+DSL) is used by many other DSL functions.

The
[API](https://goa.design/reference/goa/design/apidsl/#func-api-a-name-apidsl-api-a:aab4f9d6f98ed71f45bd470427dde2a7)
function defines the general properties of the API: the title and description used in the
documentation, the terms of service (not shown in the example above) the default host and
scheme used in the documentation and clients and the base path to all the API endpoints
(optionally also corresponding base parameters captured via wildcards defined in the base
path).

The function also defines the media types supported by the API. The
[Consumes](https://goa.design/reference/goa/design/apidsl/#func-consumes-a-name-apidsl-consumes-a:aab4f9d6f98ed71f45bd470427dde2a7)
and
[Produces](https://goa.design/reference/goa/design/apidsl/#func-produces-a-name-apidsl-produces-a:aab4f9d6f98ed71f45bd470427dde2a7)
functions make it possible to define the support media types for requests (`Consumes`) and
responses (`Produces`) optionally also specifying an encoding package that the generated code
uses to unmarshal request payloads and marshal response bodies.

There are a number of other properties that can be defined in the 
[API](https://goa.design/reference/goa/design/apidsl/#func-api-a-name-apidsl-api-a:aab4f9d6f98ed71f45bd470427dde2a7)
function ranging from
additional metadata (contact information) to security definitions,
[CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS) policies and
response templates. See the
[reference](https://goa.design/reference/goa/design/apidsl/#func-api-a-name-apidsl-api-a:aab4f9d6f98ed71f45bd470427dde2a7)
for the complete list.

## API Endpoints

Apart from the root API definition the goa API design language also makes it possible to describe
the actual endpoints together with details on the shape of the requests and responses. The
`Resource` function defines a set of related API endpoints - a resource if the API is RESTful. Each
actual endpoint is described using the `Action` function. Here is an example of a simple `Operands`
resource exposing an `add` action (API endpoint):

```go
var _ = Resource("Operands", func() {        // Defines the Operands resource
    Action("add", func() {                   // Defines the add action
        Routing(GET("/add/:left/:right"))    // The relative path to the add endpoint
        Description("add returns the sum of :left and :right in the response body")
        Params(func() {                      // Defines the request parameters
                                             // found in the URI (wildcards) and querystring
            Param("left", Integer, "Left operand")   // Defines left parameter as path segment
                                                     // captured by :left
            Param("right", Integer, "Right operand") // Define right parameter as path segment
                                                     // captured by :right
        })
        Response(OK, "plain/text")           // Defines response
    })
})
```

A `Resource` function may define any arbitrary number of actions. The resource optionally
defines a common base path, common path parameters and other properties shared by all its
actions. An action may define multiple routes (the `Routing` function argument is variadic) in
case the same endpoint can be requested from different paths or using different HTTP methods.

The DSL used to define the action parameters allows for specifying validation rules ranging
from minimum and maximum values for integer and number parameters to patterns defined via
regular expressions for string parameters:
```go
Param("left", Integer, "Left operand", func() {
    Minimum(0) // Do not allow for negative values.
})
```
The syntax used to define parameters is the
[Attribute](https://goa.design/reference/goa/design/apidsl/#func-attribute-a-name-apidsl-attribute-a:aab4f9d6f98ed71f45bd470427dde2a7)
DSL described in the section below.

### File Servers

The [Files](https://goa.design/reference/goa/design/apidsl/#func-files-a-name-apidsl-files-a)
function makes it possible to define file servers on resources. A file server serves a static file
or all files under a given file path if the route ends with a wildcard starting with `*`. The
[Files](https://goa.design/reference/goa/design/apidsl/#func-files-a-name-apidsl-files-a) function
optionally accepts a child DSL (anonymous function as last argument) for defining a security scheme.
The syntax is identical to the syntax used to define the security scheme of an action.

The following example defines a `public` resource with two file servers, one serving the file
`public/swagger/swagger.json` for requests sent to `/swagger.json` and the other all files under
`public/js/` for requests sent to `/js/*filepath` where the value of `*filepath` corresponds to the
path of the file relative to `/public/js`. The swagger endpoint also defines a security scheme
requiring clients to auth before being able to retrieve the swagger specification.

```go
var _ = Resource("public", func() {

    Origin("*", func() {        // CORS policy that applies to all actions and file servers
        Methods("GET")          // of "public" resource
    })

    Files("/swagger.json", "public/swagger/swagger.json", func() {
        Security("basic_auth")  // Security scheme implemented by /swagger.json endpoint
    })

    Files("/js/*filepath", "public/js/") // Serve all files under the public/js directory
})
```

## Data Types

The goa API design language makes it possible to describe arbitrary data types that the API may
use to define both request payloads and response media types. The
[Type](https://goa.design/reference/goa/design/apidsl/#func-type-a-name-apidsl-type-a:aab4f9d6f98ed71f45bd470427dde2a7)
function describes a data structure by listing each field using the
[Attribute](https://goa.design/reference/goa/design/apidsl/#func-attribute-a-name-apidsl-attribute-a:aab4f9d6f98ed71f45bd470427dde2a7)
function. It can also make use of the
[ArrayOf](https://goa.design/reference/goa/design/apidsl/#func-arrayof-a-name-apidsl-arrayof-a:aab4f9d6f98ed71f45bd470427dde2a7)
function to define arrays or fields that are arrays. Here is an example:

```go
// Operand describes a single operand with a name and an integer value.
var Operand = Type("Operand", func() {
    Attribute("name", String, "Operand name", func() { // Attribute name of type string
        Pattern("^x")                                  // with regex validation
    })
    Attribute("value", Integer, "Operand value")  // Attribute value of type integer
    Required("value")                             // only value is required
})

// Series represents an array of operands.
var Series = ArrayOf(Operand)
```

Note that like the `API` function the `Type` function accepts two arguments: a name and a DSL
describing the type properties. The `Type` DSL consists of three functions:

* [Description](https://goa.design/reference/goa/design/apidsl/#func-description-a-name-apidsl-description-a:aab4f9d6f98ed71f45bd470427dde2a7)
  sets the type description.
* [Attribute](https://goa.design/reference/goa/design/apidsl/#func-attribute-a-name-apidsl-attribute-a:aab4f9d6f98ed71f45bd470427dde2a7)
  defines a single type field.
* [Required](https://goa.design/reference/goa/design/apidsl/#func-required-a-name-apidsl-required-a:aab4f9d6f98ed71f45bd470427dde2a7)
  lists the required fields: fields that must always be present in instances of the type.

Types can be used to define action payloads (amongst other things):

```go
Action("sum", func() {          // Defines the sum action
    Routing(POST("/sum"))       // The relative path to the add endpoint
    Description("sum returns the sum of all the operands in the response body")
    Payload(Series)             // Defines the action request body shape using the Series
                                // type defined above.
    Response(OK, "plain/text")  // Defines a response
})
```

### Attributes

Attributes play a special role in the goa DSL. They are the base used to define data
structures. The attribute DSL is used to describe type fields, request parameters, request
payloads, response headers, response bodies etc. basically anywhere that requires defining a
data structure. The syntax for defining attributes is very flexible allowing to specify as
little or as much as needed, the complete definition is:

```go
Attribute(<name>, <type>, <description>, <dsl>)
```

Only the first argument is required, all other arguments are optional. The default attribute
type is `String`. The possible types for attributes are:

| Name       | Go equivalent | JSON equivalent   |
|------------|---------------|-------------------|
| `Boolean`  | bool          | "true" or "false" |
| `Integer`  | int           | number            |
| `Number`   | float         | number            |
| `String`   | string        | string            |
| `DateTime` | time.Time     | RFC3339 string    |
| `UUID`     | uuid.UUID     | RFC4122 string    |
| `Any`      | interface{}   | ?                 |


Additionally type fields can be defined using `ArrayOf` or `HashOf` or by using a recursive DSL:

```go
var User = Type("user", func() {
    Description("A user of the API")
    Attribute("name")                 // Simple string attribute
    Attribute("address", func() {     // Nested definition, defines a struct in Go
        Attribute("number", Integer, "Street number")
        Attribute("street", String, "Street name")
        Attribute("city", String, "City")
        Required("city")              // The address must contain at least a city
    })
    Attribute("friends", ArrayOf("user"))
    Attribute("data", HashOf(String, String))
})
```

Note the use of the `"user"` type name to define the `friends` field instead of referring to
the `User` type variable. Both syntax are accepted. Using names instead of variable reference
allows for building recursive definitions.

The [examples](https://github.com/goadesign/examples) Github repository contains a `types`
directory with a number of example demonstrating the mapping between design types and generated
code.

## Responses

### Response Media Types

Looking at responses next, the goa design language `MediaType` function describes media types which
represent the shape of response bodies. The definition of a media types is similar to the definition
of types (media types are a specialized kind of type) however there are two properties unique to
media types:

* **Views** make it possible to describe different renderings of the same media type. Often times an
  API uses a "short" representation of a resource in listing requests and a more detailed
  representation in requests that return a single resource. Views cover that use case by providing a
  way to define these different representations. A media type definition *must* define the default
  view used to render the resources (aptly named `default`).

* **Links** represent related media types that should be rendered embedded in the response. The view
  used to render links is `link` which means that media types being linked to must define a `link`
  view. Links are listed under the `Links` function in the media type definition. Views may then
  use the special `Links` function to render all the links.

Here is an example of a media type definition:

```go
// Results is the media type that defines the shape of the "add" action response.
var Results = MediaType("vnd.application/goa.results", func() {
    Description("The results of an operation")
    Attributes(func() {                              // Defines the media type attributes
        Attribute("value", Integer, "Results value") // Operation results attribute
        Attribute("requester", User)                 // Requester attribute
    })
    Links(func() {             // Defines the links embedded in the media type
        Link("requester")      // One link to the requester, will be rendered
                               // using the "link" view of User media type.
    })
    View("default", func() {   // Defines the default view
        Attribute("value")     // Includes the "value" field in the default view
        Links()                // And render links
    })
    View("extended", func() {  // Defines the extended view
        Attribute("value")     // Includes the value field
        Attribute("requester") // and the requester field
    })
})

// User is the media type used to render user resources.
var User = MediaType("vnd.application/goa.users", func() {
    Description("A user of the API")
    Attributes(func() {
        Attribute("id", UUID, "Unique identifier")
        Attribute("href", String, "User API href")
        Attribute("email", String, "User email", func() {
            Format("email")
        })
    })
    View("default", func() {
        Attribute("id")
        Attribute("href")
        Attribute("email")
    })
    View("link", func() { // The view used to render links to User media types.
        Attribute("href") // Here only the href attribute is rendered in links.
    })
})
```

### Other Response Fields

Apart from the response shape, defining API responses also requires specifying the status code and
the valid values for other HTTP headers. This is done using the `Response` function which accepts
the name of the response, the media type identifier and optionally an anonymous function listing
additional properties (HTTP status, headers etc.). As always the
[reference](https://goa.design/reference/goa/design/apidsl/#func-response-a-name-apidsl-response-a:aab4f9d6f98ed71f45bd470427dde2a7)
lists all the possible DSL, here is an example:

```go
Action("sum", func() {    // Defines the sum action.
    Routing(POST("/sum")) // The relative path to the sum endpoint.
    Description("sum returns the sum of all the operands in the response body")
    Payload(Series)       // Defines the action request body shape.
    Response("created", "vnd.application/goa.results", func() { // Defines the response
        Status(201)       // using the media type defined above and status code 201.
    })
})
```

Note that the media type identifier (`vnd.application/goa.results` in the example above) may or
may not correspond to the identifier of a media type defined via the `MediaType` function. The
generated code uses the Go type `[]byte` to define the type of the response body when the media
type identifier doesn't match a media type defined in the design.

### Response Templates

The goa API design language allows defining *response templates* at the API level that any
action may leverage to define its responses. Such templates may accept an arbitrary number of
string arguments to define any of the response properties. goa provides response templates for
all standard HTTP code that define the status so that it is not required to define templates
for the simple case. Here is an example of a response template definition:

```go
var _ = API("My API", func() {
    ResponseTemplate(Created, func(hrefPattern string) { // Defines the "created" template
        Description("Resource created") // that takes one argument.
        Status(201)                     // using status code 201
        Header("Location", func() {     // and contains the "Location" header
            Pattern(hrefPattern)        // with a regex validation defined by the
                                        // value of the argument.
        })
    })
})
```

Response templates are used in action definitions as follows:

```go
Action("sum", func() {         // Defines the sum action
    Routing(POST("/sum"))      // The relative path to the add endpoint
    Description("sum returns the sum of all the operands in the response body")
    Payload(Series)            // Payload defines the action request body shape.
    Response(Created, "^/results/[0-9]+") // Response defines a response using the
                               // Created response template.
})
```

## Conclusion

There is [a lot more](/reference/goa/design/apidsl/) to the design language but this overview
should have given you a sense for how it works. It doesn't take long for the language to feel
natural which makes it possible to quickly iterate and refine the design. The
[Swagger](/design/swagger/) specification generated from the design can be shared with stakeholders
to gather feedback and iterate. Once finalized [goagen](/implement/goagen/) generates the API
scaffolding, request contexts and validation code from the design thereby baking it into the
implementation. The design becomes a living document always up-to-date with the implementation.
